# Section 4: Food Tracker App

## 28) Demo

This lesson gives a brief overview of what the app we're building in this section.
It's a food tracker that visualizes a list of dates, and it shows the calories and macros for each day and have the functionality to add food for a day as well as view all the foods eaten on a given day.
It also saves previously added foods for quick access for adding again later on.

## 29) The Starting HTML Files:

This section covers downloading the starting html files for this particular web app, alongside this is also a deeper look into the functionalities and what we're starting out with functionality wise on the html files.

## 30) Adding Templates

We're starting out with some basic flask setup.
Then we'll get 3 routes initialized to match up with the 3 html file pages that'll be on the app.
Once the routes are set up and loading successfully, we'll add in the css files for styling.
To add the css files, we create the static folder in our working directory and add them to it.
We'll also be updating the templates to look for the CSS file:
    "<link href="{{ url_for('static', filename='bootstrap.min.css') }} rel="styleshoot">"
    "<link href="{{ url_for('static', filename='theme.css') }}>"
With this we'll save and reload the app to check that the styling is coming through on all 3 html files.

## 31) Creating the Database:

At this point we'll need to create the database as the entire functionality of this app relies on a database to work.
This time we're going to be creating the database and it's tables in a different manner.
We'll have 3 tables, one for keeping track of the dates in the app, a list of all the foods that have been added, and then one to 
track when a food gets applied to a date.
Now in the file that'll create the tables, we'll write the code to create the tables:
    "create table table_name (
        column_name column_params
    )"
We'll save the file as 'food_tracker.sql'
If we want to create a primary key that is the combination of 2 other columns, when creating the table, we use the following code:
    "primary key(column1, column2, ...)"
Now in the terminal, we'll create a database named "food_log.db":
    "sqlite3 food_log.db < food_tracker.sql"
So in the video the above code is used, however it doesn't work in a windows powershell terminal, so instead we'll use:
    "cat filename.sql | sqlite3 dbname.db"
Then once the database has been created, we'll verify that the tables were created and that we can access the tables even if there's nothing in them yet.

## 32) Adding Database Helpers:

We'll now add the code for actually working with the database.
This includes the connect_db and get_db functions for getting the db connection to be able to execute queries on it, 
as well as the app.teardown to close the db after every route has finished executing.
And we'll import the libraries we need for these functions.
Lastly we'll load all the pages as a quick test to check there's no issue with the code.

## 33) Working with the Food Form:

The first functionality we're going to add is the ability to add food items into the database.
By starting with this functionality we can build the app in such a way that there will always be data to work with for testing.
Now looking at the form we've got built, the first thing we'll do is ensure the form actually works.
As we analyze the existing template, upon testing the button to add a food item, we see that it does not work, so we'll address that first.
So we change the form's submit action to run a POST to itself, meaning we need to allow for GET and POST requests.
We'll then add the logic governing the POST and GET method handling for this route.
Once done we test, confirm the code we've done so far isn't calling any errors.
Now we want to be able to get the data from the form, so back in the HTML file, we want to make sure that each input has a name so that 
it can be passed to the flask app.
Then we'll test that these values are being passed to the app, because remember that form data comes as a name-value pair, hence why we need the name.
Also it's good practice to test every little functionality made as that doing too much in one go can make it difficult to isolate an error and 
the resolution of the error could render other works done meaningless as well.
Once we're getting a successful output showcasing the form data we know we've successfully achieved retreiving form data.

## 34) Inserting Food Data into the Database:

Now that we know our form is working correctly, we can take it's data and put it into the database.
The first thing we'll is, within the POST request method of the form, get the 4 form values and save them to variables.
We'll then also add in a calories variable, however this value is calculated based on the fat, protein and carbs.
    "calories = (fat*9)+(protein*4)+(carbs*4)"
Note we should also convert the retrieved form values to int type to prevent errors.
Then once we have these values we'll go ahead and insert them into the database.
We also took out the POST method return and else statement, so that the route returns the get method version regardless of the request method used.
As things stand, we have no indication that the food was successfully loaded, as regardless of the success of the sql insert, a fresh form is loaded.
So for now we'll shut down the app and go into the database to verify manually.
Upon confirming the entry is in the table, for good measure we should also confirm the calorie calculation is also correct.
And we'll relaunch the app and load another food for good measure.
We'll do one last check on the database and if all is good then that's this functionality completed.

## 35) Display all Foods in Database:

We want to see all the foods that are already in the database to show up under the food entry form so we don't accidentally re-enter an existing food.
And to get our food in the database we'll have to write a query to do so.
So we'll do a number of formats, firstly, we'll move the get_db above the if statement.
Now we'll query the database to fetch all food items from it outside the if statement.
Then we'll add the results to what gets fed into the template render.
Now in the add_food.html file, we'll look for where we are displaying the food items.
We'll encase the unordered list tags that we have in a for loop which will loop over each item in the results we passed to the template
which it'll iterate over and dynamically read the items into the unordered list entries.
However, if we test it now, the items are rather cramped ontop of eachother, and in the lesson, the page-header class gets moved to create spacing, 
but a simply <hr> spacer does the trick just fine.
Lastly, we'll test the full functionality off the food app by adding one more food to the database.
So upon adding a food, the page should refresh and the food just adding should show up at the bottom of the list of foods.

## 36) Inserting the Date:

Having completed the intended functionality of the food page, we'll now focus on the index page.
The functionality we want to add is for a user to be able to add a date and then have the day appear in a list.
The date will be entered in the input box, and once the user has clicked the "add" button, the page will refresh and we'll 
be able to see the date listed below.
Once again the first thing to do will be to enable POST and GET requests to this route.
Then we'll run the request method if statement.
For now we'll test to see what the date format is when fetched from the input, so we'll give the input a name so we can retrieve the 
name:value pair from it upon form submission, then we'll return it's value for a post request.
Then we save, launch the app and test it.
We see we get it back in the "YYYY-MM-DD" format.
However, we want to save the date in the database without any dashes in them, in a "YYYYMMDD" format, and then want to 
be able to output it in the list as a formatted date: "Month DD, YYYY" for example: "January 17th, 2022"
For now, we'll test it out in the terminal, so we'll call up the python interpreter and set up a dummy date variable.
To do all this, we need the datetime module:
    "from datetime import datetime"
Now to get it into the database format (no dashes), we're going to use the following line of code:
    "parse_date = datetime.strptime(date, '%Y-%m-%d')"
What this does is it parses the date as a string and returns it, however we need to pass in a format string to tell the 
strptime function how to format the date string, where %Y represent year, %m month and %d day.
Now if we print the variable containing the formatted date, we'll get a datetime object with the various parts of the date separated.
So we now want to convert it into the string that'll go into the database:
    "db_date = datetiem.strftime(parse_date, '%Y%m%d')"
And with this we have the date in the format we want it in.
Lastly, to convert it into the full date for the displayed list we'll use:
    "display_date = datetime.strftime(parse_date, '%B %d, %Y')"
Here, %B gives us the full month name.
Now with this, back in our code, under the if method = 'POST' block, we format the date into the db_date, then insert and commit into the database.
After that, outside the if block, we do a fetch everything from the log_date table to get all the dates for display.
And once we have the results saved we can pass it into the template to be looped through and displayed.