# Section 4: Food Tracker App

## 28) Demo

This lesson gives a brief overview of what the app we're building in this section.
It's a food tracker that visualizes a list of dates, and it shows the calories and macros for each day and have the functionality to add food for a day as well as view all the foods eaten on a given day.
It also saves previously added foods for quick access for adding again later on.

## 29) The Starting HTML Files:

This section covers downloading the starting html files for this particular web app, alongside this is also a deeper look into the functionalities and what we're starting out with functionality wise on the html files.

## 30) Adding Templates

We're starting out with some basic flask setup.
Then we'll get 3 routes initialized to match up with the 3 html file pages that'll be on the app.
Once the routes are set up and loading successfully, we'll add in the css files for styling.
To add the css files, we create the static folder in our working directory and add them to it.
We'll also be updating the templates to look for the CSS file:
    "<link href="{{ url_for('static', filename='bootstrap.min.css') }} rel="styleshoot">"
    "<link href="{{ url_for('static', filename='theme.css') }}>"
With this we'll save and reload the app to check that the styling is coming through on all 3 html files.

## 31) Creating the Database:

At this point we'll need to create the database as the entire functionality of this app relies on a database to work.
This time we're going to be creating the database and it's tables in a different manner.
We'll have 3 tables, one for keeping track of the dates in the app, a list of all the foods that have been added, and then one to 
track when a food gets applied to a date.
Now in the file that'll create the tables, we'll write the code to create the tables:
    "create table table_name (
        column_name column_params
    )"
We'll save the file as 'food_tracker.sql'
If we want to create a primary key that is the combination of 2 other columns, when creating the table, we use the following code:
    "primary key(column1, column2, ...)"
Now in the terminal, we'll create a database named "food_log.db":
    "sqlite3 food_log.db < food_tracker.sql"
So in the video the above code is used, however it doesn't work in a windows powershell terminal, so instead we'll use:
    "cat filename.sql | sqlite3 dbname.db"
Then once the database has been created, we'll verify that the tables were created and that we can access the tables even if there's nothing in them yet.

## 32) Adding Database Helpers:

We'll now add the code for actually working with the database.
This includes the connect_db and get_db functions for getting the db connection to be able to execute queries on it, 
as well as the app.teardown to close the db after every route has finished executing.
And we'll import the libraries we need for these functions.
Lastly we'll load all the pages as a quick test to check there's no issue with the code.

## 33) Working with the Food Form:

The first functionality we're going to add is the ability to add food items into the database.
By starting with this functionality we can build the app in such a way that there will always be data to work with for testing.
Now looking at the form we've got built, the first thing we'll do is ensure the form actually works.
As we analyze the existing template, upon testing the button to add a food item, we see that it does not work, so we'll address that first.
So we change the form's submit action to run a POST to itself, meaning we need to allow for GET and POST requests.
We'll then add the logic governing the POST and GET method handling for this route.
Once done we test, confirm the code we've done so far isn't calling any errors.
Now we want to be able to get the data from the form, so back in the HTML file, we want to make sure that each input has a name so that 
it can be passed to the flask app.
Then we'll test that these values are being passed to the app, because remember that form data comes as a name-value pair, hence why we need the name.
Also it's good practice to test every little functionality made as that doing too much in one go can make it difficult to isolate an error and 
the resolution of the error could render other works done meaningless as well.
Once we're getting a successful output showcasing the form data we know we've successfully achieved retreiving form data.

## 34) Inserting Food Data into the Database:

Now that we know our form is working correctly, we can take it's data and put it into the database.
The first thing we'll is, within the POST request method of the form, get the 4 form values and save them to variables.
We'll then also add in a calories variable, however this value is calculated based on the fat, protein and carbs.
    "calories = (fat*9)+(protein*4)+(carbs*4)"
Note we should also convert the retrieved form values to int type to prevent errors.
Then once we have these values we'll go ahead and insert them into the database.
We also took out the POST method return and else statement, so that the route returns the get method version regardless of the request method used.
As things stand, we have no indication that the food was successfully loaded, as regardless of the success of the sql insert, a fresh form is loaded.
So for now we'll shut down the app and go into the database to verify manually.
Upon confirming the entry is in the table, for good measure we should also confirm the calorie calculation is also correct.
And we'll relaunch the app and load another food for good measure.
We'll do one last check on the database and if all is good then that's this functionality completed.

## 35) Display all Foods in Database:

We want to see all the foods that are already in the database to show up under the food entry form so we don't accidentally re-enter an existing food.
And to get our food in the database we'll have to write a query to do so.
So we'll do a number of formats, firstly, we'll move the get_db above the if statement.
Now we'll query the database to fetch all food items from it outside the if statement.
Then we'll add the results to what gets fed into the template render.
Now in the add_food.html file, we'll look for where we are displaying the food items.
We'll encase the unordered list tags that we have in a for loop which will loop over each item in the results we passed to the template
which it'll iterate over and dynamically read the items into the unordered list entries.
However, if we test it now, the items are rather cramped ontop of eachother, and in the lesson, the page-header class gets moved to create spacing, 
but a simply <hr> spacer does the trick just fine.
Lastly, we'll test the full functionality off the food app by adding one more food to the database.
So upon adding a food, the page should refresh and the food just adding should show up at the bottom of the list of foods.

## 36) Inserting the Date:

Having completed the intended functionality of the food page, we'll now focus on the index page.
The functionality we want to add is for a user to be able to add a date and then have the day appear in a list.
The date will be entered in the input box, and once the user has clicked the "add" button, the page will refresh and we'll 
be able to see the date listed below.
Once again the first thing to do will be to enable POST and GET requests to this route.
Then we'll run the request method if statement.
For now we'll test to see what the date format is when fetched from the input, so we'll give the input a name so we can retrieve the 
name:value pair from it upon form submission, then we'll return it's value for a post request.
Then we save, launch the app and test it.
We see we get it back in the "YYYY-MM-DD" format.
However, we want to save the date in the database without any dashes in them, in a "YYYYMMDD" format, and then want to 
be able to output it in the list as a formatted date: "Month DD, YYYY" for example: "January 17th, 2022"
For now, we'll test it out in the terminal, so we'll call up the python interpreter and set up a dummy date variable.
To do all this, we need the datetime module:
    "from datetime import datetime"
Now to get it into the database format (no dashes), we're going to use the following line of code:
    "parse_date = datetime.strptime(date, '%Y-%m-%d')"
What this does is it parses the date as a string and returns it, however we need to pass in a format string to tell the 
strptime function how to format the date string, where %Y represent year, %m month and %d day.
Now if we print the variable containing the formatted date, we'll get a datetime object with the various parts of the date separated.
So we now want to convert it into the string that'll go into the database:
    "db_date = datetiem.strftime(parse_date, '%Y%m%d')"
And with this we have the date in the format we want it in.
Lastly, to convert it into the full date for the displayed list we'll use:
    "display_date = datetime.strftime(parse_date, '%B %d, %Y')"
Here, %B gives us the full month name.
Now with this, back in our code, under the if method = 'POST' block, we format the date into the db_date, then insert and commit into the database.
After that, outside the if block, we do a fetch everything from the log_date table to get all the dates for display.
And once we have the results saved we can pass it into the template to be looped through and displayed.
Thus far we have through testing confirmed that the POST function is still working, we just need to complete the show date functionality.

## 37) Query all Dates:

Now that we're able to add dates into the database, we want to be able to get a list of all the dates that are in the databse and list them.
To start off we'll query the database to fetch all items in it, but we'll only pull the entry_date.
Note that the query will be getting updated later to support having the fod information populated on a given day as well.
Now we want to pass the results to the template, but because it's a special datatype from the sqlite3.Row we need to format it into a new list.
For this, we need to parse the flat string with strptime using %Y%m%d, and then format it using strftime into the pretty date and make a list of the date.
Then once the dates are formatted and listed, we can pass it to the template and implement a for loop to loop over the dates list dislaying the dates.
For reference, we have to use strptime before strftime because the datetime module won't recognize a string as a date at first, so we're telling it
to recognize the string as a date and how the date string is laid out, and this way it can convert it into a date, and from there can we only 
format the date object.
Lastly, currently we notice that the dates are in the order that they were added to the database, which is not necessarily chronological order, so to fix this
we'll add an "ORDER BY" sort to the query so that our data is received in order, we specify desc so that the most recent dates are at the top.

## 38) Day Screen:

Now that we have dates displaying on the home screen, we need to be able to add dates so that we can calculate the totals for a given day in the home screen.
Now on the view screen, the first thing we want to do is to add an entry to a date.
And in order to do this, we first need to access the date so that we know what day we're adding the food to.
So we'll add a parameter to the route so that the date can be specified.
So we'll add a date parameter in the URL and it'll be expected to come in in the same format as a date stored in the database.
Once we have the date we'll query the database for that particular date.
We'll now check that we're querying the database successfully and passing a proper date to the database.
Now we'll parse and format the date we've fetched from the database to pass into the template.
The reason we query the database is two-fold: firstly, we want to ensure an entered date is in the databse, and we're setting the route up for
future improvements that we'll be making in future.
Once we've implemented this, well confirm the functionality is working and if it is we should see the formatted date entered in the URL at the top of the page.
Next we'll populate the dropdown menu with all the food items in the food database table, with the idea that we'll be able to select a food item
from the dropdown menu and hit add to add the food item to that particular day.
From the food table we'll need the id and names of all foods so that we can reference the food item when we add it.
Then we pass the results to the render_template, where we can loop through the results in a for loop.
Every dropdown menu item will take a food.name item.
We'll then test that all the food items are listed at this point as intended.
Now we naturally need to pass the id's of the food items as well when we select one, and we'll do this by adding the food item's id as the value of the particular option in the loop.
We'll test again and use the inspect option in the browser to confirm the IDs of the option.
Next we'll test submitting the form to ensure we're getting back the data we want back for when we update the database.
Firstly we'll give the form we've been working with an action to execute when we submit and the action will be to load the same route again as a post method.
We'll also need to give the select a name so that we can correctly retrieve the name:value pair from the form.
NOTE: within a variable block call, multiple variables can be called in a single block, a pair of {{}} isn't needed per variable.
So we've passed the database date format into the template as well to be able to work with the dates dynamically during testing instead of hard-coding the date.
Then we'll add an if block to check for POST request type and return the selected food item id upon a post request to ensure the data is being passed correctly.
